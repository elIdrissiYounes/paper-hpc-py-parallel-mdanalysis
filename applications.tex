\label{use_cases}

\subsection{MDAnalysis}
Simulation data exist in trajectories in the form of three dimensional time series (atoms positions and velocities), and these come in a plethora of different and idiosyncratic file formats. 
\package{MDAnalysis} is a widely used open source Python library to analyze these trajectory files with an object oriented interface. 
The package is written in Python (compatible with version 2.7 and 3.4+), with time critical code in C/Cython. 
\label{sec:mda}

\subsubsection{Root Mean Square Distance (RMSD)}
The calculation of the root mean square distance (\textbf{RMSD}) for C$_{\alpha}$ atoms after
optimal superposition with the QCPROT algorithm \cite{Liu:2010kx,Theobald:2005vn} is commonly required in the analysis of molecular dynamics simulations (Algorithm \ref{alg:RMSD}). 
The task used for the purpose of our benchmark is the $RMSD=\sqrt{\frac{1}{N}\sum_{i=1}^{N}\delta_{i}^{2}}$ implemented in MDAnalysis.analysis.rms module where $\delta_{i}$ is the distance between atom i and a reference structure (implemented in Cython \cite{Gowers:2016aa}).  
This function computes the RMSD between two sets of coordinates using the fast QCPROT algorithm to optimally superimpose two structures and then calculates the RMSD. 

To this, the protein structure (selected C$_{\alpha}$ atoms) in the initial frame will be considered as the reference and as the mobile group at other time steps. 
The superposition is done in the following way:
First, the mobile group is translated so that its center of mass coincides with the one of reference. 
Second, a rotation matrix is computed that spatially aligns the mobile group to reference which minimizes the RMSD between the coordinates of the mobile group and reference structure. 
Finally, all atoms in mobile group are shifted and rotated.
For each frame, a non-negative floating point number is calculated and the final result is a time-series of the RMSD. 
RMSD values show how rigid the domains in a protein structure are, during the transition. 
The order of complexity for RMSD algorithm \ref{alg:RMSD} is $T \times N^{2}$ \cite{rmsd} where T is the number of frames in the trajectory and N the number of particles in a 
frame.
\obnote{I suggest we put the actual python code with line numbers and without timing probes into an Appendix.}
\mknote{Will be added to appendix}

\begin{algorithm}[ht!]
	\scriptsize
	\caption{MPI-parallel Multi-frame RMSD Algorithm}
	\label{alg:RMSD}
	\hspace*{\algorithmicindent} \textbf{Input:} \emph{size}: Total number of frames \\
	\hspace*{\algorithmicindent} \emph{ref}: mobile group in the initial frame which will be considered as reference \\
	\hspace*{\algorithmicindent} \emph{start \& stop}: Starting and stopping frame index\\
	\hspace*{\algorithmicindent} \emph{topology \& trajectory}: files to read the data structure from \\
	\hspace*{\algorithmicindent} \textbf{Output:} Calculated RMSD arrays
	\begin{algorithmic}[1]
		\Procedure{$Block\_RMSD$}{topology, trajectory, $ref$, start, stop}                       
		\State u = Universe(topology, trajectory)\Comment{u hold all the information of the physical system}
		\State $g$ = u.frames[start:stop]
		\For{$\forall iframe$ in $g$}
		\State $results[iframe] = RMSD(g, ref)$
		\EndFor
		\State \Return results
		\EndProcedure
		\\        
		\State MPI Init
		\State rank = MPI\_WORLD.rank
		\State index = indices of mobile atom group
		\State xref0 = mobile.positions-mobile.center\_of\_mass()
		\State out = Block\_RMSD(topology, trajectory, xref0, start=start, stop=stop)
		\\
		\State Gather(out, RMSD\_data, root=0)
		\State MPI Finalize
	\end{algorithmic}
\end{algorithm}

\subsubsection{Dihedral Featurization}
As a real-world compute-bound task we investigated \textbf{Dihedral featurization} \cite{Sittel:2014aa} (Algorithm \ref{alg:Dihedral}) whereby a time series of
feature vectors consisting of the two backbone dihedral angles per residue ($\phi_{i}$ and $\psi_{i}$) is calculated for all 212
non-terminal residues. For each frame, an array of dihedral angles is calculated where for later convenience, an angle $\theta_{i}$ is
actually represented as $(\cos\theta_{i}, \sin\theta_{i})$. 
The order of complexity for Dihedral featurization algorithm (Algorithm \ref{alg:Dihedral}) is $T \times N$. 
\obnote{Write out the calculation, based on the 4 atoms}
\mknote{What calculations? how residues are converted to dihedrals? or the procedure we perform in the algorithm? that one is explained in algorithm 2}

\begin{algorithm}[ht!]
	\scriptsize
	\caption{Dihedral Featurization}
	\label{alg:Dihedral}
	\hspace*{\algorithmicindent} \textbf{Input:} \emph{mobile}: the desired atom groups to perform RMSD on them \\ 
	\hspace*{\algorithmicindent} \emph{start \& stop}: that tell which block of trajectory (frames) is assigned to each rank \\
	\hspace*{\algorithmicindent} \emph{topology \& trajectory}: files to read the data structure from \\
	\hspace*{\algorithmicindent} \textbf{Output:} Calculated Dihedral Angles
	\begin{algorithmic}[1]
		\Procedure{$angle2sincos$}{x}     
		\State \Return $\cos{x},\: \sin{x}$
		\EndProcedure
		\\
		\Procedure{$residues\_to\_dihedrals$}{residues}
		\State List angles
		\For{$\forall res$ in $residues$}
		\State Append $(\phi (res),\: \psi (res))$ in angles
		\EndFor
		\State \Return angles
		\EndProcedure
		\\
		\Procedure{$featurize\_dihedrals$}{dihedrals}
		\State List angles
		\For{$\forall dihedral$ in $dihedrals$}
		\State Append value of $dihedral$ in angles
		\EndFor
		\State \Return \texttt{angle2sincos(angles)}
		\EndProcedure
		\\
		\Procedure{$Block\_Dihedral$}{topology, trajectory, $ref$, start, stop}                       
		\State u = Universe(topology, trajectory)
		\State $g$ = u.frames[start:stop]\Comment{The selected frames} 
		\State List $results$
		\For{$\forall frame$ in $g$}
		\State $D_{angles}=featurize\_dihedrals(dihedrals)$
		\State Append $D_{angles}$ in $results$ 
		\EndFor
		\EndProcedure
		\\      
		\State MPI Init 
		\State residues = residues of mobile atom group
		\State dihedrals = residues\_to\_dihedrals(residues)
		\State rank = MPI\_WORLD.rank
		\State index = indices of mobile atom group
		\State xref0 = mobile.positions-mobile.center\_of\_mass()
		\State out = Block\_Dihedral(topology, trajectory, xref0, start=start, stop=stop)
		\\
		\State Gather(out, RMSD\_data, root=0)\Comment{Gather all data to rank 0}
		\State MPI Finalize
	\end{algorithmic}
\end{algorithm}

